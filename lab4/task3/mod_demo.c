/*
 * @file mod_demo.c
 * @brief Demo program to generate modulated output based on a given input sequence
 * @author ECE486 Lab Group 8
 * @author Christian Auspland
 * @author Matthew Blanchard
 * @author Ben Grooms
 *
 * @date March 25, 2018
 */

#include "stm32l4xx_hal.h"
#include "stm32l476g_discovery.h"

#include "ece486.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "arm_math.h"
#include "modulation.h"
#include "ece486_IQ_mixer.h"

extern FlagStatus KeyPressed;   // Use to detect button presses

int main(void)
{
  int nsamp = 0;
  int i = 0;
  int btnCount = 0;
  float Fs = 0;

  IQ_MIXER_T *mixer_cos;
  IQ_MIXER_T *mixer_sin;
  MOD_T mod;


  char lcd_str[8];

  char inputSeq[20] = {0,0, 0,1, 1,1, 1,0, 0,1, 0,1, 1,1, 0,0, 1,0, 1,1};
  float bitrate = 1e+3;
  float A = 1.0/1.5;

  /*
   * Set up ADCs, DACs, GPIO, Clocks, DMAs, and Timer
   *
   * If your discovery board has been modified to support the external
   * HSE reference, use the (better quality crystal controlled) HSE
   * configuration.  If not, you can use the MSI reference, and things
   * should still work -- but your clocks will drift over time.
   *
   * The MSI (Medium speed internal) reference is the on-chip RC oscillator
   *
   * The HSE (High speed external) reference is an external clock, either
   * provided through the external connector, or (if your board is modified)
   * from the crystal reference source generated by the other processor
   * on the development board.
   */
  initialize_ece486(FS_200K, MONO_IN, STEREO_OUT, MSI_INTERNAL_RC);

  /*
   * Allocate Required Memory
   */
  nsamp = getblocksize();

  float *input = (float *)malloc(sizeof(float)*nsamp);
  float *cos_buf = (float *)malloc(sizeof(float)*nsamp);
  float *sin_buf = (float *)malloc(sizeof(float)*nsamp);
  float *output_re = (float *)malloc(sizeof(float)*nsamp);
  float *output_im = (float *)malloc(sizeof(float)*nsamp);
  float *output = (float *)malloc(sizeof(float)*nsamp);

  Fs = getsamplingfrequency();
  if (input==NULL || output_re==NULL || output_im==NULL) {
    flagerror(MEMORY_ALLOCATION_ERROR);
    while(1);
  }

  /*
   * Normally we avoid printf()... especially once we start actually
   * processing streaming samples.  This is here to illustrate the
   * use of printf for debugging programs.
   *
   * To see the printf output, connect to the ST-Link serial port.
   * Use: 115200 8N1
   */
  printf("Starting execution using %d samples per input block,Fs = %f.\n",nsamp,Fs);

  /*
   * Infinite Loop to process the data stream, "nsamp" samples at a time
   */

  // Initialize mixers/modulators
  mixer_cos = init_IQ_mixer((2 * 3.14156 * 12e+3) / Fs);
  mixer_sin = init_IQ_mixer((2 * 3.14156 * 12e+3) / Fs);

  init_mod(&mod, OOK, A, Fs, bitrate, inputSeq, 20);

  while(1){
    /*
     * Ask for a block of ADC samples to be put into the working buffer
     *   getblock() will wait here until the input buffer is filled...  On return
     *   we work on the new data buffer... then return here to wait for
     *   the next block
     */
    getblock(input);

    /*
     * signal processing code to calculate the required output buffers
     */

    DIGITAL_IO_SET(); 	// Use a scope on PD0 to measure execution time

    calc_mod(&mod, cos_buf, sin_buf, nsamp);


    calc_IQ_mixer(mixer_cos, cos_buf, output_re, input, nsamp);
    calc_IQ_mixer(mixer_sin, sin_buf, input, output_im, nsamp);

    for (i = 0; i < nsamp; i++) {
      output[i] = output_re[i] + output_im[i];
    }


    DIGITAL_IO_RESET();	// (falling edge....  done processing data )

    /*
     * pass the processed working buffer back for DAC output
     */
    putblockstereo(output,input);

    if (KeyPressed) {
      KeyPressed = RESET;
      btnCount++;
      btnCount = btnCount % 4;

      switch (btnCount) {
        case 0:
          sprintf(lcd_str,"OOK   ");
          destroy_mod(&mod);
          init_mod(&mod, OOK, A, Fs, bitrate, inputSeq, 20);
          break;
        case 1:
          sprintf(lcd_str,"ASK   ");
          destroy_mod(&mod);
          init_mod(&mod, ASK, A, Fs, bitrate, inputSeq, 20);
          break;
        case 2:
          sprintf(lcd_str,"BPSK  ");
          destroy_mod(&mod);
          init_mod(&mod, BPSK, A, Fs, bitrate, inputSeq, 20);
          break;
        case 3:
          sprintf(lcd_str,"QPSK  ");
          destroy_mod(&mod);
          init_mod(&mod, QPSK, A, Fs, bitrate, inputSeq, 20);
          break;
      }
      BSP_LCD_GLASS_DisplayString( (uint8_t *)lcd_str);
      BSP_LED_Toggle(LED5);
    }
  }
}
