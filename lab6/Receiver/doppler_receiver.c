/*!
 * @file doppler_receiver.c
 *
 * @brief Doppler receiver implementation for Lab 6
 *
 * @author ECE486 Lab Group 8
 * @author Christian Auspland
 * @author Matthew Blanchard
 * @author Ben Grooms
 * @author Hunter Smith
 *
 * @date April 21, 2018
 *
 */

 #include "stm32l4xx_hal.h"
 #include "stm32l476g_discovery.h"

 #include "ece486.h"
 #include <stdlib.h>
 #include <math.h>
 #include "arm_math.h"
 #include "arm_const_structs.h"
 #include "fft.h"
 #include "filter.h"
 #include "window.h"
 #include "peak_finder.h"

 extern FlagStatus KeyPressed;   // Use to detect button presses

 int main(void)
 {
   int nsamp = 0;           // Blocksize
   float Fs = 0;            // Sampling frequency
   int i = 0;               // Loop index
   int j = 0;
   int k = 0;
   fft_size fft_N = FFT_SIZE_2048;   // Size of the FFT
   int window_N = 10;       // N paramter for the Blackman-Harris window
   float *input_re;         // Real input
   float *input_im;         // Imaginary input
   float *filtered_re;      // Filtered real signal
   float *filtered_im;      // Filtered imaginary signal
   float *filtered_cpx;     // Combined filtered complex signal
   float *windowed_cpx;     // Complex filtered windowed complex signal
   float *output;           // Output FFT magnitude spectrum
   arm_biquad_cascade_df2T_instance_f32 S_re;  // ARM Biquad filter instance
   arm_biquad_cascade_df2T_instance_f32 S_im;  // ARM Biquad filter instance


   char lcd_str[8];       // LCD display string

   /*
    * Set up ADCs, DACs, GPIO, Clocks, DMAs, and Timer
    *
    * If your discovery board has been modified to support the external
    * HSE reference, use the (better quality crystal controlled) HSE
    * configuration.  If not, you can use the MSI reference, and things
    * should still work -- but your clocks will drift over time.
    *
    * The MSI (Medium speed internal) reference is the on-chip RC oscillator
    *
    * The HSE (High speed external) reference is an external clock, either
    * provided through the external connector, or (if your board is modified)
    * from the crystal reference source generated by the other processor
    * on the development board.
    */
    setblocksize(700);
    initialize_ece486(FS_50K, STEREO_IN, STEREO_OUT, MSI_INTERNAL_RC);


   // Allocate Required Memory. windowed_cpx is oversized. Unused indices (those
   // in excess of the blocksize nsamp) will remain 0, functioning as the zero
   // padding for the FFT
   nsamp = getblocksize();
   Fs = getsamplingfrequency();
   input_re     = (float *)calloc(nsamp, sizeof(float));
   input_im     = (float *)calloc(nsamp, sizeof(float));
   filtered_re  = (float *)calloc(nsamp, sizeof(float));
   filtered_im  = (float *)calloc(nsamp, sizeof(float));
   //filtered_cpx = (float *)calloc((nsamp * 2) / 5, sizeof(float));
   windowed_cpx = (float *)calloc(fft_N * 2, sizeof(float));
   output       = (float *)calloc(fft_N, sizeof(float));

   // Initialize CFFT structure
   FFT_T *fft = init_fft(fft_N);
   S_re = make_filter();
   S_im = make_filter();
   float *window = init_window_blackman_harris(window_N, nsamp/5);

   while(1){

     // Aquire real/imaginary signals from the ADC
     getblockstereo(input_re, input_im);

     DIGITAL_IO_SET(); 	// Use a scope on PD0 to measure execution time

     // Input filtering stage: passband 2kHz, stopband 8kHz. Decimate.
     arm_biquad_cascade_df2T_f32(&S_re, input_re, filtered_re, nsamp);
     arm_biquad_cascade_df2T_f32(&S_im, input_im, filtered_im, nsamp);

     // Combine the filtered real & imaginary signals into a complex signal, using
     // interleaving as required by the CMSIS library:
     // complex_buffer = real[0], imag[0], real[1], imag[1], ...
     // Also, decimate by 5
     j = 0;
     k = 0;
     for (i = 0; i < (nsamp/5)*2; i+=2) {
       windowed_cpx[i]     = filtered_re[j] * window[k];
       windowed_cpx[i+1]   = filtered_im[j] * window[k];
       j += 5;
       k += 1;
        //filtered_cpx[2*i]     = filtered_re[i*5];
	      //filtered_cpx[(2*i)+1] = filtered_im[i*5];
     }
     for (i = ((nsamp/5)*2); i < (fft_N * 2); i++) {
       windowed_cpx[i] = 0;
     }

     // Perform a complex multiply between the filtered complex signal and
     // the window function. The results are stored in windowed_cpx, which will
     // consist of nsamp smaples of data followed by fft_N - nsamp zeros of padding
     // untouched by this function
     //arm_cmplx_mult_real_f32(filtered_cpx, window, windowed_cpx, nsamp/5);

     // Calculate the FFT of the complex, filtered, windowed, zero-padded signal
     calc_fft(fft, windowed_cpx, output);

     // Determine the index of the furthest peak
     int peak_index = find_peak(output, Fs/5, fft_N);

     DIGITAL_IO_RESET();	// (falling edge....  done processing data )

     putblockstereo(output, output);
     //putblockstereo(input_re, input_re);
     //putblockstereo(filtered_re, filtered_re);

      if (window == NULL) {
        sprintf(lcd_str, "OH SHIT");
        BSP_LCD_GLASS_DisplayString( (uint8_t *)lcd_str);
      } else {
        sprintf(lcd_str, "%d", (int)windowed_cpx[3000]);
        BSP_LCD_GLASS_DisplayString( (uint8_t *)lcd_str);
      }
   }

   destroy_fft(fft);
 }
